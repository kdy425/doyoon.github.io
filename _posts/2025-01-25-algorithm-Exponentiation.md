---
title: "빠른 모듈러 거듭제곱 알고리즘 이해하기"
categories:
  - algorithm
  - math
  - cryptology
tags:
  - 거듭제곱
  - 모듈러 연산
  - 빠른 거듭제곱
  - 알고리즘
---

---


## 들어가며

**빠른 모듈러 거듭제곱 알고리즘**은 큰 수의 거듭제곱을 효율적으로 계산하기 위한 방법입니다. 특히 모듈러 연산과 결합하여 큰 수 계산에서 중간 값이 너무 커지는 것을 방지하며 정확한 결과를 빠르게 얻을 수 있습니다.

---

## 기본 개념 이해하기

### 거듭제곱 (Exponentiation)

- 어떤 수를 여러 번 곱하는 연산입니다.
- **예**: \( 2^5 = 2 * 2 * 2 * 2 * 2 = 32 \)

### 모듈러 연산 (Modulo Operation)

- 어떤 수를 다른 수로 **나눈 나머지**를 구하는 연산입니다.
- **표현**: \( a mod m \)
- **예**: \( 17 mod 5 = 2 \) (17을 5로 나눈 나머지는 2)

### 모듈러 거듭제곱

- 거듭제곱 결과를 특정 수로 나눈 나머지를 구하는 것.
- **예**: \( 3^4 mod 5 = 81 mod 5 = 1 \)

---

## 왜 빠른 거듭제곱 알고리즘이 필요한가요?

- **큰 지수의 거듭제곱**은 계산량이 매우 많습니다.
  - **예**: \( 2^{1000} \)은 \( 2 \)를 1000번 곱해야 합니다.
- **효율적인 계산 방법**이 없다면 실제로 계산하기 어렵습니다.
- **빠른 거듭제곱 알고리즘**은 계산 횟수를 **대폭 줄여줍니다**.
- 암호에서 자주쓰입니다.

---

## 빠른 거듭제곱 알고리즘의 아이디어

### 거듭제곱의 성질 활용

- **지수법칙**을 사용하여 계산을 단순화합니다.

#### 지수법칙

1. **지수가 짝수일 때**:
   \[
   a^n = {a^(n/2)}^2
   \]
2. **지수가 홀수일 때**:
   \[
   a^n = a * {a^(n-1)/2}^2
   \]

---

## 단계별로 쉽게 살펴보기

### 예시: \( 5^{13} mod 100 \) 계산

#### 초기 설정

- `result = 1`
- `base = 5`
- `exponent = 13`

#### 반복 과정

1. **exponent = 13 (홀수)**
   - `result = (result * base) % 100 = (1 * 5) % 100 = 5`
   - `base = (base * base) % 100 = (5 * 5) % 100 = 25`
   - `exponent = 13 // 2 = 6`

2. **exponent = 6 (짝수)**
   - `base = (base * base) % 100 = (25 * 25) % 100 = 25`
   - `exponent = 6 // 2 = 3`

3. **exponent = 3 (홀수)**
   - `result = (result * base) % 100 = (5 * 25) % 100 = 25`
   - `base = (base * base) % 100 = (25 * 25) % 100 = 25`
   - `exponent = 3 // 2 = 1`

4. **exponent = 1 (홀수)**
   - `result = (result * base) % 100 = (25 * 25) % 100 = 25`
   - `base = (base * base) % 100 = (25 * 25) % 100 = 25`
   - `exponent = 1 // 2 = 0`

#### 최종 결과

- `result = 25`
- 따라서 \( 5^{13} mod 100 = 25 \)

---

## 지수가 홀수일 때의 처리 방법

### 왜 결과에 기반을 곱하는가?

- 지수가 홀수이면 짝수로 만들어서 계산하는 것이 효율적입니다.
- 수학적으로:
  \[
  a^{2k+1) = a * (a ^ k)^2
  \]
- 따라서, **결과(result)에 현재의 기반(base)을 곱하고**, 지수를 1 감소시켜 짝수로 만듭니다.

---

## 알고리즘 작동 과정 예시

### 예시: \( 2^7 \mod m \) 계산 (m은 임의의 모듈러 값)

#### 초기값

- `result = 1`
- `base = 2`
- `exponent = 7`

#### 반복 과정

1. **exponent = 7 (홀수)**
   - `result = (result * base) % m`
   - `base = (base * base) % m`
   - `exponent = (exponent - 1) // 2`

2. **exponent = 3 (홀수)**
   - `result = (result * base) % m`
   - `base = (base * base) % m`
   - `exponent = (exponent - 1) // 2`

3. **exponent = 1 (홀수)**
   - `result = (result * base) % m`
   - `base = (base * base) % m`
   - `exponent = (exponent - 1) // 2`

#### 최종 결과

- 지수가 0이 될 때까지 반복하여 `result`를 구합니다.

---

## 알고리즘의 핵심 요약

- **기반(base)을 제곱하면서** 지수를 절반으로 줄여나갑니다.
- **지수가 홀수일 때**는 결과(result)에 기반(base)을 한 번 더 곱해주어 지수를 짝수로 만듭니다.
- 이 과정을 지수가 0이 될 때까지 반복합니다.

---

## 코드 구현

이제 빠른 모듈러 거듭제곱 알고리즘을 활용하여 실제 문제를 해결해보겠습니다.

### 예제 문제: 수퍼 바이러스(Softeer)
https://softeer.ai/practice/6292

**문제 설명**

- 수퍼 바이러스가 숙주의 몸속에서 **0.1초당 P배씩** 증가합니다.
- 처음에 수퍼 바이러스 **K마리**가 있습니다.
- **N초 후**에는 총 몇 마리의 수퍼 바이러스로 불어날까요?
- N초 동안 죽는 수퍼 바이러스는 없다고 가정합니다.
- 수퍼 바이러스는 일반 바이러스에 비해서 훨씬 오래 생존할 수 있기 때문에 N이 매우 클 수 있습니다.

**제약 조건**

- \( 1 <= K <= 10^8 \)
- \( 1 <= P <= 10^8 \)
- \( 1 <= N <= 10^16 \)

**입력 형식**

- 첫 번째 줄에 처음 바이러스의 수 \( K \), 증가율 \( P \), 총 시간 \( N \) (초)이 주어집니다.

**출력 형식**

- 최종 바이러스 개수를 **1,000,000,007로 나눈 나머지**를 출력합니다.

### 해결 방법

- 바이러스는 **0.1초당 P배씩** 증가하므로, **1초당 10번** 증가합니다.
- 따라서 **N초 후 총 증가 횟수**는 \( N \times 10 \)번입니다.
- 최종 바이러스 수는 다음과 같이 계산됩니다:
  \[
  \text{최종 바이러스 수} = K * P^{N * 10} mod 1,000,000,007
  \]
- 지수가 매우 크기 때문에, **빠른 거듭제곱 알고리즘**을 사용하여 \( P^{N * 10} mod 1,000,000,007 \)을 효율적으로 계산해야 합니다.

### 코드

```cpp
#include <iostream>

const long long MOD = 1000000007;

// 빠른 모듈러 거듭제곱 함수
long long mod_pow(long long base, long long exponent, long long modulus) {
    long long result = 1;
    base %= modulus; // 기반을 modulus로 나눠 초기화

    while (exponent > 0) {
        if (exponent % 2 == 1) { // 지수가 홀수인 경우
            result = (result * base) % modulus; // 결과에 기반을 곱하고 모듈러 연산
        }
        base = (base * base) % modulus; // 기반을 제곱하고 모듈러 연산
        exponent /= 2; // 지수를 절반으로 감소
    }

    return result;
}

int main() {
    long long K, P, N;
    std::cin >> K >> P >> N;

    long long exponent = N * 10; // 총 증가 횟수 계산

    // P^(N*10) mod MOD 계산
    long long growth = mod_pow(P, exponent, MOD);

    // 최종 바이러스 수 계산
    long long final_count = (K * growth) % MOD;

    std::cout << final_count << std::endl;

    return 0;
}
